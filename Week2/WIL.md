# Weekly I Learned

## 포인터

포인터를 사용하면 변수가 저장하는 값이 아닌 변수의 주소를 알 수 있다.
예를 들어 "int i=5;"가 있다고 하자
i를 참조하는 "int* ptr=&i;"를 선언한다면
포인터 변수 ptr은 i의 메모리 주소를 저장하고 있다고 할 수 있다.
ptr이 i를 참조한다는 것은 ptr이 i의 메모리 주소를 저장하고 있어서, ptr을 통해 i의 값을 접근할 수 있다는 의미이다. 배열같은 경우 배열의 이름이 배열의 0번인덱스의 주소가 된다.

## &와 *

& 연산자는 변수의 주소를 가져온다
예를 들어 "int* ptr=&i;"라고 한다면 ptr이라는 변수에 i의 주소를 저장하는 것이 된다.
\* 연산자는 포인터의 이름이나 주소 앞에 사용하여, 포인터가 가리지는 주소에 저장된 값을 반환한다.
위의 예시를 이어 ptr을 이용해 i가 저장하고 있는 "값"을 받고 싶다면 "*ptr"을 사용하면 된다.
&는 주소를 가져오고 *은 주소를 이용해 값을 가져오고. 처음 설명을 들을 때는 이렇게 역함수의 개념으로 이해했다.

## 1주차에 공부했던 &연산자 내용 복기

scanf로 값을 받을 때 "scanf("%d",&i);"이런 식으로 i의 주소를 명시해야 입력을 받을 수 있었다.
하지만 문자열의 경우 다르다 "scanf("%s",str);" 이런 식으로 배열의 이름만 명시해도 입력을 받을 수 있다.
이유는 배열과 문자열의 경우 그 이름 자체가 포인터이기 때문이다.

## 포인터를 사용하는 이유

C언어 이야기를 하다보면 항상 포인터에 관한 이야기를 들었다. 그래서 그 포인터라는 게 뭔지 배우기 전까지 항상 궁금했었다. 그래서 사실 포인터가 뭔지 간단하게 배우고 나서는 왜 이 내용이 그렇게 대표적인 내용이고 중요한 내용인지 잘 와닿지 않았다. 그래서 포인터를 사용해야 하는 이유를 더 탐구해보았다.~~날 만족시켜줘~~

- 큰 데이터 처리
큰 데이터 구조를 함수에 전달할 때 포인터를 사용하면 데이터 전체를 복사하지 않고도 함수가 데이터에 접근할 수 있다. 메모리를 낭비하지 않고 그 메모리에 접근하는 길만 전달하면 된다는 것이 유리한 것 같다.
- 변수의 스코프
포인터는 변수의 스코프와 관련된 다양한 문제를 해결할 수 있다.
지역변수는 함수가 종료되면 소멸한다. 하지만 포인터를 사용하면 함수의 실행이 끝난 후에도 데이터를 유지하고 다른 함수와 공유할 수 있다. 변수의 주소를 전달하여 함수 간에 데이터를 공유할 수 있다. 지역변수의 한계를 극복하고 다양한 함수에서 데이터를 사용할 수 있다.
- 트리
트리, 그래프를 구현하는 데 필수적이라고 한다. 아직 C언어로 트리, 그래프를 구현해보지 않았지만, 노드와 노드를 연결하는 포인터로 구성된다고 한다. 무슨 느낌인지 알 것 같다.
- 콜백 함수
포인터의 역할을 조사하다 콜백 함수에 대해 알게 됐다. 처음에 콜백 함수의 개념에 대해서 공부할 때는 잘 와닿지 않았다. 그냥 함수의 인자에 다른 함수의 반환값을 받는 거라고 생각했어서 뭐가 특별한 건지 포인터는 무슨 상관인지 그냥 평범한 재귀논리아닌지 의아했다. 하지만 콜백함수는 단순히 함수의 인자에 다른 함수의 반환값을 받는 것과 차이점이 있다.
함수의 반환값을 인자로 받는 경우에는 함수가 실행된 후, 반환된 값을 인자로 본 함수가 사용한다. 즉 호출되는 함수가 먼저 실행되고 그 결과를 사용하는 것이다.
하지만 콜백함수는 호출하는 함수 내에서 특정 시점에 실행되도록 미리 정의된 함수이다. 즉, 호출하는 함수가 실행되는 동안 특정 조건이나 작업이 완료되었을 때 콜백 함수를 호출한다.
함수의 실행 시점을 조작할 수 있는 것이다. 따라서 실행 흐름을 더 유연하게 제어할 수 있다.
그럼 여기서 포인터의 역할은 무엇이냐, 포인터는 콜백 함수의 주소를 저장하고, 이 주소를 이용해 나중에 해당 함수를 호출할 수 있도록 한다. 함수의 실행 시점을 조작할 수 있게 하는 중요한 역할을 한다. 포인터를 사용하면 다양한 함수를 동적으로 유연하게 호출할 수 있다는 것이 무슨 뜻인지 조금 알 것 같다.

반해버릴 것 같다 재밌다 설렌다.
